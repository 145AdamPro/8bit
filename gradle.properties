# Done to increase the memory available to gradle.
org.gradle.jvmargs=-Xmx3G
org.gradle.parallel=true

# Fabric Properties
# check these on https://fabricmc.net/develop
minecraft_version=1.21.1
yarn_mappings=1.21.1+build.3
loader_version=0.16.9

# Mod Properties
mod_version=2.0.0
maven_group=we.devs.opium
archives_base_name=opium

# Dependencies
fabric_version=0.110.0+1.21.1




package we.devs.opium.client.modules.misc;

import net.minecraft.block.BlockState;
import net.minecraft.client.input.Input;
import net.minecraft.client.network.ClientPlayerEntity;
import net.minecraft.client.option.KeyBinding;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.hit.HitResult;
import net.minecraft.util.math.*;
import we.devs.opium.api.manager.module.Module;
import we.devs.opium.api.manager.module.RegisterModule;
import we.devs.opium.api.utilities.MovementUtils;
import we.devs.opium.client.events.EventRender3D;
import we.devs.opium.client.values.impl.ValueBoolean;
import we.devs.opium.client.values.impl.ValueNumber;

@RegisterModule(name = "FreecamSmooth", description = "Fly around freely with smooth block-facing", category = Module.Category.MISC)
public class ModuleFreecamSmooth extends Module {

    private Vec3d camPos = Vec3d.ZERO;
    private float yaw, pitch;

    private final ValueNumber speed = new ValueNumber("Speed", "Speed", "", 0.3, 0.05, 3);
    private final ValueBoolean faceBlock = new ValueBoolean("FaceBlock", "Rotate to block", true);
    private final ValueNumber smoothness = new ValueNumber("Smoothness", "Rotation smoothness", "", 0.2, 0.01, 1);

    private boolean active = false;

    @Override
    public void onEnable() {
        if (mc.player == null) return;

        camPos = mc.player.getPos();
        yaw = mc.player.getYaw();
        pitch = mc.player.getPitch();
        active = true;
    }

    @Override
    public void onDisable() {
        active = false;
    }

    @Override
    public void onTick() {
        if (!active || mc.player == null) return;

        Vec3d forward = getDirectionVector(yaw, pitch).normalize();
        Vec3d velocity = Vec3d.ZERO;

        // Handle input
        Input input = mc.player.input;
        if (input.pressingForward) velocity = velocity.add(forward);
        if (input.pressingBack) velocity = velocity.subtract(forward);
        if (input.pressingLeft) velocity = velocity.add(getDirectionVector(yaw - 90, 0));
        if (input.pressingRight) velocity = velocity.add(getDirectionVector(yaw + 90, 0));
        if (mc.options.jumpKey.isPressed()) velocity = velocity.add(0, 1, 0);
        if (mc.options.sneakKey.isPressed()) velocity = velocity.add(0, -1, 0);

        // Apply speed
        camPos = camPos.add(velocity.normalize().multiply(speed.getValue().doubleValue()));

        if (faceBlock.getValue()) {
            HitResult hit = mc.crosshairTarget;
            if (hit instanceof BlockHitResult bhr) {
                Vec3d lookTarget = Vec3d.ofCenter(bhr.getBlockPos());
                float[] angles = getRotationsTo(camPos, lookTarget);

                yaw = smoothAngle(yaw, angles[0], smoothness.getValue().floatValue());
                pitch = smoothAngle(pitch, angles[1], smoothness.getValue().floatValue());
            }
        }

        // Override camera
        mc.gameRenderer.setRenderHand(false);
        mc.setCameraEntity(new FreecamEntity(mc.world, camPos, yaw, pitch));
    }

    @Override
    public void onRender3D(EventRender3D event) {
        if (!active) return;
        // Optional: render camera position box
    }

    private float smoothAngle(float current, float target, float smoothFactor) {
        float delta = MathHelper.wrapDegrees(target - current);
        return current + delta * smoothFactor;
    }

    private float[] getRotationsTo(Vec3d from, Vec3d to) {
        Vec3d diff = to.subtract(from);
        double dist = MathHelper.sqrt((float) (diff.x * diff.x + diff.z * diff.z));
        float yaw = (float) Math.toDegrees(Math.atan2(diff.z, diff.x)) - 90f;
        float pitch = (float) -Math.toDegrees(Math.atan2(diff.y, dist));
        return new float[]{yaw, pitch};
    }

    private Vec3d getDirectionVector(float yaw, float pitch) {
        float radYaw = (float) Math.toRadians(yaw);
        float radPitch = (float) Math.toRadians(pitch);

        float x = -MathHelper.sin(radYaw) * MathHelper.cos(radPitch);
        float y = -MathHelper.sin(radPitch);
        float z = MathHelper.cos(radYaw) * MathHelper.cos(radPitch);

        return new Vec3d(x, y, z);
    }

    // Fake entity to control camera
    private static class FreecamEntity extends PlayerEntity {
        private final Vec3d pos;
        private final float yaw, pitch;

        public FreecamEntity(net.minecraft.world.World world, Vec3d pos, float yaw, float pitch) {
            super(mc.world, mc.player.getBlockPos(), mc.player.getYaw(), mc.player.getGameProfile());
            this.pos = pos;
            this.yaw = yaw;
            this.pitch = pitch;
        }

        @Override public Vec3d getPos() { return pos; }
        @Override public float getYaw() { return yaw; }
        @Override public float getPitch(float tickDelta) { return pitch; }
        @Override public boolean isSpectator() { return true; }
        @Override public boolean isCreative() { return true; }
    }
}